package MyModule;
#define a namespace by declaring a package name

use strict;
#good to restrict the use of global variables.

use Exporter;
#need to use the Exporter module to export our functions
 
use vars qw($VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);

$VERSION     = 1.00;
@ISA         = qw(Exporter);

@EXPORT      = ();
#contains a list of functions that we export by default

@EXPORT_OK   = qw(func1 func2);
#contains a list of functions that we export on demand so we 
#export &func1 &func2 only if specifically requested to

%EXPORT_TAGS = ( DEFAULT => [qw(&func1)],
                 Both    => [qw(&func1 &func2)]);
#For convenience we define two sets of export tags. 
#The ':DEFAULT' tag exports only &func1; 
#the ':Both' tag exports both &func1 &func2.

############################################
sub func1  { return reverse @_  }
sub func2  { return map{ uc }@_ }

############################################
A simple script to use MyModule)
#!/usr/bin/perl -w
use strict;

# you may need to set @INC here
#When using MyModule; perl searchs the @INC array for a 
#module with the correct name. @INC usually contains: 
#/perl/lib 
#/perl/site/lib
#.
The . directory (dot dir) is the current working directory. 
#CORE modules are installed under perl/lib whereas non-CORE 
#modules install under perl/site/lib. You can add directories 
#to the module search path in @INC like this: 
#BEGIN { push @INC, '/my/dir' }
# or
#BEGIN { unshift @INC, '/my/dir' }
# or
#use lib '/my/dir';
#
#use Foo::Bar does not mean look for a module called "Foo::Bar.pm" in
#the @INC directories. It means search @INC for a *subdir* called 
#"Foo" and a *module* called "Bar.pm". 
#

my @list = qw (J u s t ~ A n o t h e r ~ P e r l ~ H a c k e r !);

# case 1:not work, func1 &func2 are not exported
# use MyModule;
# print func1(@list),"\n";
# print func2(@list),"\n";

# case 2:works, func1 is exported; func2 is OK with full name 
# use MyModule qw(&func1);
# print func1(@list),"\n";
# print MyModule::func2(@list),"\n";

# case 3: not work for func2
# use MyModule qw(:DEFAULT);
# print func1(@list),"\n";
# print func2(@list),"\n";

# case 4: works fine
# use MyModule qw(:Both);
# print func1(@list),"\n";
# print func2(@list),"\n";


########## passing our between modules
#Foo.pm:
#package Foo;
#use strict; use warnings;
#use parent 'Exporter'; # imports and subclasses Exporter
#our $var = 42;
#our $not_exported = "don't look at me";
#our @EXPORT = qw($var); # put stuff here you want to export
# put vars into @EXPORT_OK that will be exported on request
#
#script.pl:
#!/usr/bin/perl
# this is implicitly package main
#use Foo; # imports $var
#
#print "var = $var\n"; # access the variable without prefix
#print "$Foo::not_exported\n"; # access non-exported var with full name
#
#
# our - default - global
# my - variable is lexically scoped to the block it's declared in
# local - previous global is stored and a new one created that only exists to
#         the end of the block it's declared in
#


